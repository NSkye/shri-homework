Домашние задания Школы Разработки Интерфейсов  

## Typescript
Проект сейчас находится в процессе полного переписывания, так как при выполнении первых заданий было мало свободного времени и мне не очень нравится как они были сделаны (верстка, история коммитов, иерархия). Старую версию проекта можно посмотреть [тут](https://github.com/NSkye/shri-18-smarthouse-task-1).  
По этой же причине в проекте отсутствуют некоторые части, связанные с версткой, но так как они не относятся к заданию по тайпскрипту, я решил, что надо сейчас отдать приоритет логике.

### Запуск
Установить пакеты:
```
npm i
```
Запуск dev server'а (будет запущен на `0.0.0.0:3000`):
```
npm start
```
Одновременно с этим будет произведен линтинг, но если линтинг нужно произвести отдельно, то
```
npm run lint
```
Задания с логикой размещаются на страницах [/#/camera](http://0.0.0.0:3000/#/camera) и [/#/videofeed](http://0.0.0.0:3000/#/videofeed). Для того чтобы второе задание работало как надо, надо развернуть видеопотоки [вот отсюда](https://github.com/mad-gooze/shri-2018-2-multimedia-homework/blob/master/streams/README.md) в отдельном терминале.  
Задание по Node.js пока что [вот тут](https://github.com/NSkye/shri-18-smarthouse-task-4/tree/typescript) (позже сделаю монорепозиторий), запуск аналогичен тому что описано выше, но линтинг по ходу сборки не производится, он работает через `npm run lint`. 

### Выполнение
- практически полностью отсутствуют типы `any`
- полностью отсутсвуют неявные типы `any`
- компиляция производится в строгом режиме
- @ts-ignore отсутствует
- `type assertions` всё же присутствуют в некоторых местах  
- используется tslint  

### Сложности
В основном сложности возникали на этапе сборки и настройки окружения, но в целом и это не заняло много времени. Дополнительных проблем добавили некоторые дефолтные декларации типов. Например, у типа `PointerEvent` нет метода `getCoalescedEvents` и его [пришлось расширять](https://github.com/NSkye/shri-homework/blob/master/src/libs/pointer-events-coalesced-events-polyfill.ts). Так же, были проблемы с привязкой ивент-листенеров, так как они передают в соответствии с декларацией в коллбэк `Event`, который не совместим с `PointerEvent`, из-за этого приходилось как раз использовать `as`, также, его пришлось заиспользовать в некоторых местах, где идет взаимодействие с window (на window байндится библиотека для стриминга HLS, а также на нем в декларации нет аудиоконтекста), поэтому иногда приходилось творить вот такую дичь:
```javascript
interface GlobalNamespace extends Window {
  AudioContext?: {new (): AudioContext};
  webkitAudioContext?: {new (): AudioContext};
}

const globalNamespace = window as GlobalNamespace;
const wAudioContext:
  { new (): AudioContext } | undefined = globalNamespace.AudioContext
  || globalNamespace.webkitAudioContext;

if (wAudioContext) {
  this.audioCtx = (new wAudioContext());
} else {
  throw Error('Browser doesnt support audiocontext');
}
```
Ещё из сложностей была функция setInterval. Согласно декларациям она возвращает тип NodeJS.Timeout, а вот функция clearInterval принимает number.
```javascript
public kill() {
    this.processingInterval = setInterval(() => this.processFrame(this.w, this.h), 1000) as unknown as number;
}
```
Мне, кстати, правда интересно как с этим справляться. Переписывать декларации? Должно же быть какое-то более элегантное решение, всё же setInterval не то чтоб какая-то редко используемая функция.   

С заданием на Node сложностей не возникло, кроме того, что я так до конца и не понял как правильно должны быть использованы декларации из express. Они в принципе работают, но у req и res сигнатура не совпадает с декларацией, выложенной в @types (совсем). Поэтому там сейчас у них стоит any.  

В целом ассершены используются только там, где происходит взаимодействие с DOM-деревом и другими внешними сущностями, которые не всегда отдают тот тип, который ты ожидаешь получить и приходится делать какие-то такие приведения: `Event -> PointerEvent`, `Element -> HTMLVideoElement`, `Vue | Vue[] | Element | Element[] -> HTMLElement`

Серьезных ошибок в процессе перевода найдено не было.  

### Итог
Я считаю, что тайпскрипт в таких небольших проектах довольно избыточный. Он не отлавливает тут очень много ошибок, но заставляет тратить гораздо больше времени, так как требует описание типов и деклараций (если, конечно, использовать его по назначению). С другой стороны мне очень пришлось по душе каким самодокументируемым с ним получается код. Я бы его использовал в больших проектах и библиотеках.  
Я буду продолжать использовать тайпскрипт в проекте по нескольким причинам:  
- Я раньше на нем не писал и учебный проект это хорошая возможность для практики
- Код действительно становится более понятным, что, наверное, удобно проверяющим
- Я почти никогда не высыпаюсь, а он отлавливает мои тупые ошибки ещё до компиляции, что вообще отлично
